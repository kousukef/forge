# architecture-patterns: 設計ガイダンス

## SOLID 原則の適用判断

### Single Responsibility

- 判定基準: 「このクラスを変更する理由は何か」を列挙し、2つ以上なら分割を検討
- ユーザー検証とメール送信のような異なる変更理由を持つ責務は分離する
- 責務の分離はコンストラクタ注入で協調させる

### Open/Closed

- 新しいバリエーション追加が既存コード変更を要求する場合、Strategy パターンで拡張に開く
- if/else や switch の分岐追加が繰り返される場合のシグナル
- 新機能は新クラスの追加で対応し、既存コードは変更しない

### Liskov Substitution + Interface Segregation

- 巨大インターフェースは実装側で例外スローの LSP 違反を招く
- 用途ごとにインターフェースを分割し、LSP 違反を構造的に防ぐ（Readable, Writable, Deletable 等）
- クライアントが使わないメソッドに依存させない

### Dependency Inversion

- 上位モジュール（ドメイン）がインターフェースを定義し、下位モジュール（インフラ）が実装
- 依存の方向: domain/ ← application/ ← infrastructure/
- フレームワーク依存はインフラ層に隔離する

## DDD 適用の判断基準

### プロジェクト規模別の推奨アプローチ

- 小規模（PoC、数画面）: レイヤー分離のみ。DDD は不要
- 中規模（10+ 画面、複数ドメイン）: モジュール分割 + Repository パターン
- 大規模（複数チーム、複雑なドメイン）: Bounded Context + Aggregate + ADR

### Bounded Context の設計

- 同じ概念でも文脈によって異なるモデルにする（User vs Customer vs BillingAccount）
- コンテキスト間は直接 import せず、イベントまたは Anti-Corruption Layer を使う
- 共有カーネルは最小限に保つ

### Aggregate の設計

- Aggregate Root 経由でのみ内部状態を変更する
- Aggregate 間の参照は ID のみ（オブジェクト参照しない）
- 1トランザクション = 1 Aggregate。トランザクション整合性の境界

### Repository パターン

- ドメインオブジェクトの保存・取得のみを担当
- クエリロジックは Repository に、ビジネスロジックはドメインに配置
- テスト時はインメモリ実装で差し替え可能にする

## モジュール境界の設計

### 境界の判定基準

- 変更頻度が異なる → 分離すべき
- チーム所有権が別 → 分離すべき
- ドメイン概念が異なるコンテキスト → 分離すべき
- デプロイ独立性が必要 → 分離すべき

### 公開 API の設計

- 各モジュールは index.ts で公開インターフェースを明示する
- 内部実装（Repository 実装、Value Object 等）は export しない
- モジュール外からの import は index.ts 経由を強制する

## レイヤードアーキテクチャ

### 4層の責務

- Presentation: リクエスト処理、レスポンス整形。フレームワーク依存 OK
- Application: ユースケース実行、トランザクション管理。オーケストレーション
- Domain: ビジネスルール、バリデーション。自己完結、フレームワーク非依存
- Infrastructure: DB 操作、外部 API 呼び出し。ドメインインターフェースの実装

### 依存ルール

- 各層は同層または下位層にのみ依存する
- Infrastructure は Domain のインターフェースを実装する（依存逆転）
- Domain は他のどの層にも依存しない

## 依存性注入の設計

### Composition Root パターン

- 依存の組み立て（new の呼び出し）はアプリのエントリーポイント付近に集約
- ドメイン層やアプリケーション層では具象クラスを new しない
- TypeScript では DI コンテナなしでもコンストラクタ注入で十分なケースが多い

### テスト容易性

- インターフェースを通じた依存注入によりモック / スタブの差し替えが容易
- インメモリ実装を用意してユニットテストを高速化

## ADR（Architecture Decision Records）

### 記録すべきタイミング

- 新モジュール・サービスの追加
- 外部ライブラリの選定（同等の選択肢が複数）
- データモデルの重要な設計判断
- パフォーマンスとのトレードオフを含む判断

### 記録内容

- コンテキスト（判断が必要になった背景）
- 決定とその理由
- 却下した選択肢と却下理由
- 正負の影響・トレードオフ

## アンチパターンと回避

- God Class: 1クラスに全責務集中。SRP に従い分割
- Circular Dependency: モジュール間の循環参照。依存逆転で解消
- Anemic Domain Model: ドメインがデータだけ。ビジネスロジックをドメインに移動
- Leaky Abstraction: インフラ詳細がドメインに漏れる。Repository で隔離
- Premature Abstraction: 1実装のみでインターフェース。2つ目が必要になってから抽象化
